\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstdefinelanguage{Lua}
{
morekeywords={and,break,do,else,elseif,end,false,for,function,if,in,local,nil,not,or,repeat,return,then,true,until,while,_G,_ENV,table,every,Repeat,If,For},
sensitive=false,
morecomment=[l]{//},
morecomment=[s]{--[[}{]]},
morestring=[b]",
morestring=[b]'
}

\lstset{style=mystyle}


\chapter{Problem statement and baseline solution analysis}
\label{chap:met}


The purpose of this chapter is to lay a foundation for the further work in this Thesis via formal definition of RRM problem and analysis of existing RRM algorithm from Wimark Systems. The chapter is organized as follows. Section \ref{sec:prob} defines the problem of RRM and its goals. Section \ref{sec:baseline} describes the baseline RRM algorithm from Wimark Systems and considerations that led to such solution.


\section{Problem statement}
\label{sec:prob}


\section{Baseline solution analysis}
\label{sec:baseline}
The greedy RRM algorithm from Wimark Systems that we will refer to as \textit{RRMGreedy} is based on background scanning by access points. The goal of this thesis is to create a new RRM algorithm that is overall better in managing radio resources and at least not worse than \textit{RRMGreedy} in corner cases.

Here, we describe \textit{RRMGreedy}.
As said by the description

\begin{lstlisting}[language={Lua}, caption=greedy RRM algorithm, label=lst:greedy]
    Algorithm RRMAlgoGreedy

    Input:
        data: RRMInitData

    Output:
        GroupDataWithEvent: final configuration and event data for CPEs

    Begin
        scandata := ProcessScanDataForGroup(data.CPEs, data.ScanData)
        Log "Initial scan data processed"

        // Step 1: Set Maximum Transmission Power
        For each cpe in data.CPEs
            For each iface in cpe.State.Wifi
                MaxIfaceTxPower := Max Tx power for given hardware
                scandata[iface].TxDiff := MaxIfaceTxPower - iface.TxPower

        // Step 2: Optimize Channel Selection
        // calculate initial group interference
        groupInterference := GroupInterference(scandata)
        Repeat until no improvement in groupInterference
            For each cpe in data.CPEs
                For each iface in cpe.State.Wifi
                    bestChannel := choose channel that minimizes InterferenceOnCPE(scandata, channel, width)
                    scandata[iface].channel := bestChannel
            Recalculate groupInterference := GroupInterference(scandata)

        // Step 3: Adjust Transmission Power (if enabled)
        If algo.ManagePower
            Repeat until no improvement in groupInterference
                Identify worst-performing interface using InterferenceFromCPE
                Calculate needpower and bestpower for worst interface
                Update scandata with new Tx power settings
                Evaluate total interference using GroupInterference

        // Step 4: Final Data Assembly and Event Generation
        finaldata, eventsData := Assemble final configuration and events
        If no significant improvement in interference
            Log "No significant changes made"
            Return error message

        Return finaldata and eventsData

    End Algorithm
\end{lstlisting}

\begin{lstlisting}[language={Lua}, caption=InterferenceOnCPE() function, label=lst:interf_on_cpe]
Function InterferenceOnCPE(scandata, interface, interfaceChannel, interfaceChannelWidth)
    sum := 0.0 // cumulative interference score for this interface
    ifData := scandata[interface]

    // Calculate interference from outer channels
    For each otherChannel in ifData.Outer
        inteferenceScore := ChannelInterference(otherChannel, interfaceChannel, interfaceChannelWidth)
        If channels are orthogonal continue
        // calculate cumulative interference score for all signals on this channel
        chsum := 0.0
        For every signal sensed on otherChannel
            sigRating := signal power (in dBm) normalized to [0, 1] scale
            chsum += interferenceScore * sigRating
        sum += chsum

    // Calculate interference from inner channels
    For each othKey, siglist in ifData.Inner
        oth, ok := data[othKey]
        If not ok
            Continue
        ci := ChannelInterference(oth.Settings.Central, ch, width)
        If ci == 0
            Continue
        chsum := 0.0
        For each sig in siglist
            adjustedSignal := sig.Signal + thisdata.TxDiff
            sigRating := CalculateSignalRating(adjustedSignal)
            chsum += ci * sigRating
        sum += chsum

    Return sum
\end{lstlisting}



